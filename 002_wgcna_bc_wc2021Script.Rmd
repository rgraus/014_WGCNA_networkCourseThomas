
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(magrittr)
source(here::here("InitializeProject.R"))
```


```{r organize_data_PRAD}
library(Biobase)
library(DESeq2)
library(org.Hs.eg.db) # change according to your organism
# This junk prepares data according to your needs. In this case, we read a counts matrix and convert it into an ENTREZID based Expression Set

# First, we create an ENTREZID based DESeq2 object, preprocess the object, covert the expression data into a vst transformed matrix and construct an ExpressionSet.

# read the counts table. This section has to be changed accordung to the data you havem see DESeq2 workflow.

counts <- rio::import(here::here(datadir, "TCGA-PRAD-counts.RDS"))

# read the sample annotation
pdata <- rio::import(here::here(datadir, "TCGA-PRAD-pdata.RDS"))

# create a map between ENSEMBLE and ENTREZID
map <- AnnotationDbi::select(org.Hs.eg.db,
                             columns = c("ENTREZID",
                                         "ENSEMBL"),
                             keys = keys(org.Hs.eg.db, keytype = "ENTREZID")) %>%
  drop_na

# convert the ENSEMBLE based count matrix into ENTREZ based counts 
counts_entrezid <- counts %>%
  rownames_to_column("ENSEMBL") %>%
  inner_join(fdata) %>%
  dplyr::select(ENTREZID, starts_with ("TCGA")) %>%
  dplyr::group_by(ENTREZID) %>%
  summarize_all(sum) %>%
  column_to_rownames("ENTREZID")


# create an annotation for the features
fdata <- AnnotationDbi::select(org.Hs.eg.db,
                             columns = c("ENTREZID",
                                         "ENSEMBL",
                                         "SYMBOL",
                                         "GENENAME"),
                             keys = keys(org.Hs.eg.db, keytype = "ENTREZID")) %>%
  group_by(ENTREZID) %>%
  summarize(ENSEMBL = paste(unique(ENSEMBL), collapse = ", "),
            SYMBOL = paste(unique(SYMBOL), collapse = ", "),
            GENENAME = paste(unique(GENENAME), collapse = ", ")) %>%
  mutate(rowname = ENTREZID) %>%
  column_to_rownames

# create a DESeq2 object. The formula is a dummy so that DESeq2 works

dds <- DESeqDataSetFromMatrix(countData = counts_entrezid,
                              colData = pdata[colnames(counts_entrezid),],
                              design = ~ 1)

featureData <- fdata[rownames(dds),] # this has to be done to ensure that the order is met
mcols(dds) <- DataFrame(mcols(dds), featureData)

# filter out lowly expressed genes

keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]

# save the DESeq2 object
dds %>%
  rio::export(here::here(datadir, "TCGA_PRAD.DEseqDataSet.RDS"))

# apply variance stabilizing transfrmation
dds_vst <- dds %>%
  vst

# create an ExpressionSet for WGCNA
eset <- ExpressionSet(assay(dds_vst))
pData(eset) <- colData(dds_vst) %>% data.frame
fData(eset) <- rowData(dds_vst) %>% data.frame



eset %>%
  rio::export(here::here(datadir, "ExpressionSet_WGCNA_PRAD.RDS")) # change name according to your needs

# and we are set for the analysis

```

```{r organize_data_Melanoma}
library(Biobase)
library(DESeq2)
library(org.Hs.eg.db) # change according to your organism
# This junk prepares data according to your needs. In this case, we read a counts matrix and convert it into an ENTREZID based Expression Set

# First, we create an ENTREZID based DESeq2 object, preprocess the object, covert the expression data into a vst transformed matrix and construct an ExpressionSet.

# read the dds object

dds <- rio::import(here::here(datadir, "GSE158403.DESeq2.RDS"))

# remove the version from the ensemblgene IDs

rownames(dds) <- str_sub(rownames(dds), 1, 15)

# extract counts

counts <- assay(dds) %>%
  data.frame

# extract pdata
pdata <- colData(dds) %>%
  data.frame

# create a map between ENSEMBLE and ENTREZID
map <- AnnotationDbi::select(org.Hs.eg.db,
                             columns = c("ENTREZID",
                                         "ENSEMBL"),
                             keys = keys(org.Hs.eg.db, keytype = "ENTREZID")) %>%
  drop_na

# convert the ENSEMBLE based count matrix into ENTREZ based counts 
counts_entrezid <- counts %>%
  rownames_to_column("ENSEMBL") %>%
  inner_join(fdata) %>%
  dplyr::select(ENTREZID, starts_with ("SRR")) %>%
  dplyr::group_by(ENTREZID) %>%
  summarize_all(sum) %>%
  column_to_rownames("ENTREZID")


# create an annotation for the features
fdata <- AnnotationDbi::select(org.Hs.eg.db,
                             columns = c("ENTREZID",
                                         "ENSEMBL",
                                         "SYMBOL",
                                         "GENENAME"),
                             keys = keys(org.Hs.eg.db, keytype = "ENTREZID")) %>%
  group_by(ENTREZID) %>%
  summarize(ENSEMBL = paste(unique(ENSEMBL), collapse = ", "),
            SYMBOL = paste(unique(SYMBOL), collapse = ", "),
            GENENAME = paste(unique(GENENAME), collapse = ", ")) %>%
  mutate(rowname = ENTREZID) %>%
  column_to_rownames

# create a DESeq2 object. The formula is a dummy so that DESeq2 works

dds <- DESeqDataSetFromMatrix(countData = counts_entrezid,
                              colData = pdata[colnames(counts_entrezid),],
                              design = ~ 1)

featureData <- fdata[rownames(dds),] # this has to be done to ensure that the order is met
mcols(dds) <- DataFrame(mcols(dds), featureData)

# filter out lowly expressed genes

keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]

# save the DESeq2 object
dds %>%
  rio::export(here::here(datadir, "Melanoma.DEseqDataSet.RDS"))

# apply variance stabilizing transfrmation
dds_vst <- dds %>%
  vst

# create an ExpressionSet for WGCNA
eset <- ExpressionSet(assay(dds_vst))
pData(eset) <- colData(dds_vst) %>% data.frame
fData(eset) <- rowData(dds_vst) %>% data.frame



eset %>%
  rio::export(here::here(datadir, "ExpressionSet_WGCNA_MELANOMA.RDS")) # change name according to your needs

# and we are set for the analysis

```


```{r WGCNA_main_body_PRAD}
library(Biobase)
library(mixtools)
library(genefilter)
library(WGCNA)
library(DESeq2)
library(org.Hs.eg.db)
# enable multithreading in WGCNA
enableWGCNAThreads(10)
options(stringsAsFactors = FALSE)

# load relavent data
eset <- rio::import(here::here(datadir, "ExpressionSet_WGCNA_PRAD.RDS"))

# filter sample - this has to be changed according to your needs

selected.samples = pData(eset) %>%
  filter(MARKER !="NA") %>%
  .$SAMPLEID

# to switch off this filter: comment if you want filtering
selected_samples <- sampleNames(eset)

# select features
selected_features = fData(eset) %>%
  filter(!grepl('uncharacterized|pseudogene|antisense RNA|smnall nucleolar RNA', GENENAME)) %>%
  rownames

# to switch off this filter: comment if you want filtering
selected_features <- featureNames(eset)
  
# optional: take all
# selected.features = c(1:nFeatcolt))
  
# filter based on ENTREZID and remove duplicates
eset_wgcna <- eset[selected_features,selected_samples]



# optional: filter the set by fitting a MOG and selecting genes with a posterior 2 > 0.5
mixmdl <- as.numeric(exprs(eset_wgcna)) %>% 
  sort() %>%
  normalmixEM()


# determine the threshold
threshold <- mixmdl$x[min(which(mixmdl$posterior[,2] > 0.5))]

# which genes are below the threshold in all samples ?
selected_genes <- apply(exprs(eset_wgcna),
                  1,
                  function(x, threshold){
                    return(!(sum(x<threshold) == length(x)))
                  },
                  threshold = threshold) %>%
  names(.)[.]

# to switch off this filter: comment if you want filtering
selected_genes <- featureNames(eset_wgcna)

# optional: filter the ExpressionSet object
eset_wgcna <- eset_wgcna[selected_genes,]

# extract the expression matrix
expression <- exprs(eset_wgcna)


ISA <- (cor(expression) + 1)/2^2

ISA %>%
  rio::export(here::here(resultsdir, "ISA.RDS"))

networkConcepts <- WGCNA::networkConcepts(expression,
                                          power = 2,
                                          networkType = "signed")

networkConcepts %>%
  rio::export(here::here(resultsdir, "networkConcepts.RDS"))

connectivity <- networkConcepts$Connectivity
clustercoefficient <- networkConcepts$ClusterCoef
zK <- (connectivity - mean(connectivity))/sqrt(sd(connectivity))
zC <- (clustercoefficient - mean(clustercoefficient))/sqrt(sd(clustercoefficient))

outliers <- names(zK)[abs(zK) > 2]

expresssion_outlier_removed <- expression[,!(colnames(expression) %in% outliers)]

# eset_wgcna <- eset_wgcna[,!(sampleNames(eset_wgcna) %in% outliers)]

# define the params for WGCNA
params <- list(networkType = "signed",
               corType = "bicor",
               maxBlockSize = 35000,
               # TOMType = "signed",
               minModuleSize = 30,
               reassignThreshold = 1e-6,
               detectCutHeight = .998,
               mergeCutHeight = 0.15,
               deepSplit = 2,
               numericLabels = TRUE,
               pamStage = TRUE,
               pamRespectsDendro = TRUE,
               verbose = 6,
               datExpr = t(expresssion_outlier_removed))
# Choose a set of soft-thresholding powers



powers = c(seq(1,10,by=1), seq(12,20, by=2));
sft = pickSoftThreshold(params$datExpr,
                        corFnc = bicor,
                        RsquaredCut = 0.8,
                        powerVector=powers,
                        networkType = params$networkType,
                        verbose = 6)

beta <- sft$powerEstimate # Berni and Renia beta <- 12
if (is.na(beta)){
  if (params$networkType == "unsigned"){
    beta <- 6
  } else {
    beta <- 12
  }
}

collectGarbage();
params$power <- beta

### construct the network in a one-step process using iterative WGCNA
# the result is a network object containing the additional element of "refinedColors".

net <- do.call(blockwiseModules, c(params)) 

net <- do.call(iterativeWGCNA, c(params)) # if not wanted - blockwiseModules)

# attach the underlying parameters and data
net$params <- as.list(args(iterativeWGCNA))
net$params <- as.list(args(blockwiseModules))
net$params[names(params)] <- params
net$eset <- eset_wgcna
# save the net object and we are finished
net %>%
  rio::export(here::here(datadir, "WGCNA_network_PRAD.RDS"))

```


```{r WGCNA_main_body_MELANOMA}
library(Biobase)
library(mixtools)
library(genefilter)
library(WGCNA)
library(DESeq2)
library(org.Hs.eg.db)
# enable multithreading in WGCNA
enableWGCNAThreads(10)
options(stringsAsFactors = FALSE)

# load relavent data
eset <- rio::import(here::here(datadir, "ExpressionSet_WGCNA_MELANOMA.RDS"))

# filter sample - this has to be changed according to your needs

selected.samples = pData(eset) %>%
  filter(MARKER !="NA") %>%
  .$SAMPLEID

# to switch off this filter: comment if you want filtering
selected_samples <- sampleNames(eset)

# select features
selected_features = fData(eset) %>%
  filter(!grepl('uncharacterized|pseudogene|antisense RNA|smnall nucleolar RNA', GENENAME)) %>%
  rownames

# to switch off this filter: comment if you want filtering
selected_features <- featureNames(eset)
  
# optional: take all
# selected.features = c(1:nFeatcolt))
  
# filter based on ENTREZID and remove duplicates
eset_wgcna <- eset[selected_features,selected_samples]



# optional: filter the set by fitting a MOG and selecting genes with a posterior 2 > 0.5
mixmdl <- as.numeric(exprs(eset_wgcna)) %>% 
  sort() %>%
  normalmixEM()


# determine the threshold
threshold <- mixmdl$x[min(which(mixmdl$posterior[,2] > 0.5))]

# which genes are below the threshold in all samples ?
selected_genes <- apply(exprs(eset_wgcna),
                  1,
                  function(x, threshold){
                    return(!(sum(x<threshold) == length(x)))
                  },
                  threshold = threshold) %>%
  names(.)[.]

# to switch off this filter: comment if you want filtering
selected_genes <- featureNames(eset_wgcna)

# optional: filter the ExpressionSet object
eset_wgcna <- eset_wgcna[selected_genes,]

# extract the expression matrix
expression <- exprs(eset_wgcna)


ISA <- (cor(expression) + 1)/2^2

ISA %>%
  rio::export(here::here(resultsdir, "ISA_MELANOMA.RDS"))

networkConcepts <- WGCNA::networkConcepts(expression,
                                          power = 2,
                                          networkType = "signed")

networkConcepts %>%
  rio::export(here::here(resultsdir, "networkConcepts_MELANOMA.RDS"))

connectivity <- networkConcepts$Connectivity
clustercoefficient <- networkConcepts$ClusterCoef
zK <- (connectivity - mean(connectivity))/sqrt(sd(connectivity))
zC <- (clustercoefficient - mean(clustercoefficient))/sqrt(sd(clustercoefficient))

outliers <- names(zK)[abs(zK) > 2]

expresssion_outlier_removed <- expression[,!(colnames(expression) %in% outliers)]

# eset_wgcna <- eset_wgcna[,!(sampleNames(eset_wgcna) %in% outliers)]

# define the params for WGCNA
params <- list(networkType = "signed",
               corType = "bicor",
               maxBlockSize = 35000,
               # TOMType = "signed",
               minModuleSize = 30,
               reassignThreshold = 1e-6,
               detectCutHeight = .998,
               mergeCutHeight = 0.15,
               deepSplit = 2,
               numericLabels = TRUE,
               pamStage = TRUE,
               pamRespectsDendro = TRUE,
               verbose = 6,
               datExpr = t(expresssion_outlier_removed))
# Choose a set of soft-thresholding powers



powers = c(seq(1,10,by=1), seq(12,20, by=2));
sft = pickSoftThreshold(params$datExpr,
                        corFnc = bicor,
                        RsquaredCut = 0.8,
                        powerVector=powers,
                        networkType = params$networkType,
                        verbose = 6)

beta <- sft$powerEstimate # Berni and Renia beta <- 12
if (is.na(beta)){
  if (params$networkType == "unsigned"){
    beta <- 6
  } else {
    beta <- 12
  }
}

collectGarbage();
params$power <- beta

### construct the network in a one-step process using iterative WGCNA
# the result is a network object containing the additional element of "refinedColors".

net <- do.call(blockwiseModules, c(params)) 

net <- do.call(iterativeWGCNA, c(params)) # if not wanted - blockwiseModules)

# attach the underlying parameters and data
net$params <- as.list(args(iterativeWGCNA))
net$params <- as.list(args(blockwiseModules))
net$params[names(params)] <- params
net$eset <- eset_wgcna
# save the net object and we are finished
net %>%
  rio::export(here::here(datadir, "WGCNA_network_MELANOMA.RDS"))

```


```{r make_dendrogram}
library(tidyverse)
library(magrittr)
library(WGCNA)
library(Biobase)
library(cowplot)

# get the network and the data
net <- rio::import(here::here(datadir, "WGCNA_network_PRAD.RDS"))

height <- 5.2/3*2

png(filename = file.path(plotsdir, "dendro.png"),
    width = height * 2,
    height = height,
    units = "in",
    res = 300
    # pointsize = font_size
)

par(mar = c(0,0,0,0))
WGCNA::plotDendroAndColors(net$dendrograms[[1]],
                           colors = data.frame(colors=labels2colors(net$colors[net$goodGenes])),
                           dendroLabels = FALSE,
                           main = "",
                           groupLabels = c("modules"),
                           cex.colorLabels = 0.75,
                           cex.axis = 0.5,
                           cex.lab = 0.8,
                           marAll = c(0,4,0,0),
                           lwd = 0.5)
dev.off()
plot <- ggdraw() +
  draw_image(file.path(plotsdir, "dendro.png")) %T>%
saveRDS(file.path(plotsdir, paste("DendrogramPlot", "RDS", sep=".")))
```

```{r calculate_association}
library(WGCNA)
library(lmerTest)
library(Biobase)

net <- rio::import(here::here(datadir, "WGCNA_network_PRAD.RDS"))

# correlate traits with module eigengenes
pdata <- pData(net$eset) %>%
  dplyr::select(barcode, sample_type) %>%
  rename(SAMPLEID = barcode) %>%
  mutate(sample_type = case_when(sample_type == "Solid Tissue Normal" ~ "NORMAL",
                                 sample_type == "Primary Tumor" ~ "TUMOR",
                                 TRUE ~ "TUMOR")) %>%
  mutate(sample_type = factor(sample_type,
                              levels = c("NORMAL", "TUMOR")))

# Define numbers of genes and samples
moduleColors = paste("M", net$colors, sep = "")
nSamples <- nrow(net$params$datExpr)

# Recalculate MEs with color labels
MEs <- WGCNA::moduleEigengenes(net$params$datExpr, moduleColors)$eigengenes %>%
  dplyr::select(!matches("M0"))

traits <- pdata %>%
  dplyr::select(sample_type) %>%
  mutate(sample_type = as.numeric(sample_type)) %>%
  as.matrix



# calculate the correlation
moduleTraitCor <- cor(MEs, as.matrix(traits[rownames(MEs),]), use = "p")
# calculate the p-value for the correlation coefficient
moduleTraitPvalue <- corPvalueStudent(moduleTraitCor, nSamples)

# Alternatively do a mixed effect model as described in Li et al

# define the model
#formula <- Y ~ sample_type + (1|prior_malignancy)
#
# create a dataframe for input
#lmeData <- MEs %>% 
#  rownames_to_column("SAMPLEID") %>%
#  pivot_longer(cols = starts_with("ME"),
#               values_to ="Y",
#               names_to = "MODULE") %>%
#  inner_join(pdata)

# Apply the linear model per Module
#lmeResult <- lmeData %>%
#  tidyr::nest(group = -"MODULE") %>%
#  mutate_at(
#    "group",
#    purrr::map,
#    function(x){
#      lmerTest::lmer(formula = formula,
#           data = x) %>%
#        summary() %>%
#        extract("coefficients") %>%
#        .$coefficients %>%
#        data.frame(stringsAsFactors = FALSE) %>%
#        rownames_to_column("COEFFICIENT")    
#      }) %>%
#  deframe() %>%
#  bind_rows(.id = "MODULE") %>%
#  dplyr::rename(p.value = Pr...t..) %>%
#  mutate(adj.P.Val = p.adjust(p.value, 
#                              method = "hochberg")) %>%
#  dplyr::filter(COEFFICIENT != "(Intercept)") %>%
#  mutate(COEFFICIENT = str_replace(COEFFICIENT, "TEC", "")) %>%
#  mutate(COEFFICIENT = str_replace(COEFFICIENT, "CD105", ""))

# calculate the t-statistics
#moduleTraitCor <- lmeResult %>%
#  dplyr::select(MODULE, COEFFICIENT, t.value) %>%
#  pivot_wider(names_from = COEFFICIENT,
#              values_from = t.value)  %>%
#  column_to_rownames("MODULE")

# calculate the adjusted p-value
#moduleTraitPvalue <-  lmeResult %>%
#  dplyr::select(MODULE, COEFFICIENT, adj.P.Val) %>%
#  pivot_wider(names_from = COEFFICIENT,
#              values_from = adj.P.Val)  %>%
#  column_to_rownames("MODULE")
#

order <- hclust(dist(moduleTraitCor))$order
moduleTraitCor <- moduleTraitCor[order,]
moduleTraitPvalue <- moduleTraitPvalue[rownames(moduleTraitCor),]


# convert the matrices into a data frame, with module annotation
moduleTraitPvalue <- moduleTraitPvalue %>%
  data.frame(stringsAsFactors = FALSE) %>%
  mutate(module = str_replace(rownames(.), "ME", "")) %>%
  pivot_longer(!matches("module"))

moduleTraitCor <- moduleTraitCor %>%
  data.frame(stringsAsFactors = FALSE) %>%
  mutate(module = str_replace(rownames(.), "ME", "")) %>%
  pivot_longer(!matches("module")) %T>%
  # save module trait cor
  saveRDS(file.path(resultsdir, "ModuleTraitCor.RDS"))

heatmap_data <- full_join(moduleTraitCor, moduleTraitPvalue, 
                      by = c("module", "name")) %>%
  mutate(label = paste(signif(value.x, 2), " (",
                       signif(value.y, 1), ")", sep = "")) %>%
  # select relevant columns
  dplyr::select(module, name, value.x, label) %>%
  
  # rename them accordingly
  dplyr::rename(Y = module, X = name, value = value.x) %>%
  mutate(X = factor(X, levels = c("CELLTYPE", "MARKER"))) %T>%
  export(file.path(resultsdir, 
                   paste(accession, 
                         "association", 
                         "RDS", 
                         sep = ".")))
```


```{r make_eigengeneplots}
library(tidyverse)
library(magrittr)
library(ggpubr)
library(WGCNA)
library(limma)
library(mdthemes)
## get the network and the data
net <- rio::import(here::here(datadir, "WGCNA_network_PRAD.RDS"))

# define the groups. The ordering of the groups in the plot happens here !!!
pdata <- pData(net$eset) %>%
  dplyr::select(barcode, sample_type) %>%
  rename(SAMPLEID = barcode) %>%
  mutate(sample_type = case_when(sample_type == "Solid Tissue Normal" ~ "NORMAL",
                                 sample_type == "Primary Tumor" ~ "TUMOR",
                                 TRUE ~ "TUMOR")) %>%
  mutate(sample_type = factor(sample_type,
                              levels = c("NORMAL", "TUMOR")))

groups <- pdata[rownames(net$params$datExpr), "sample_type"]
# define comparisons
comparisons <- list(c("TUMOR", "NORMAL"))

# extract the module colors
moduleColors = paste("M", net$colors, sep = "")

# Calculate MEs with color labels
data <- WGCNA::moduleEigengenes(net$params$datExpr, moduleColors)$eigengenes %>%
  
  # remove grey
  dplyr::select(-MEM0) %>%
  
  # rename the color names from ME<color> to <color>
  rename_all(~ str_replace(.,"ME", "")) %>%
  
  # add the sampleID
  rownames_to_column(var = "SAMPLE") %>%
  
  # add the groups
  mutate(GROUP = groups) %>%
  
  # pivot to long representation
  pivot_longer(!(matches("SAMPLE") | matches("GROUP")),
               names_to = "MODULE",
               values_to = "VALUE") %>%
  
  # add the color
  mutate(COLOR = WGCNA::labels2colors(as.numeric(str_replace(MODULE, "M", ""))))

eigengene.plots.violin <- data %>%
  tidyr::nest(GROUP = -"MODULE") %>%
  deframe() %>%
  purrr::map2(names(.),
              function(x,y){
                # calculate the p-values
                #comparison <- compare_means(VALUE ~ GROUP, 
                #                            x, 
                #                            method = "t.test", 
                #                            p.adjust.method = "hochberg") %>%
                  # mutate(y.position = c(0.375, 0.5, 0.625, 0.75, 0.875, 1)) %>%
                  # mutate(x.min = c()) %>%
                  # mutate(p.sci = paste(scientific_10(p.adj))) %>%
                  # mmutate(p.sci = paste("expression(", p.sci, ")", sep = "")) %>%
                 # dplyr::filter(p.adj < 0.05)
                # call the plotting function
                ggplot(x, aes(x = GROUP,
                              y = VALUE))+ 
                  geom_violin(stat="ydensity",
                              fill = unique(x$COLOR),
                              size = 0.25) +
                  geom_boxplot(width=0.1,
                               size = 0.25,
                               outlier.size=0.1) +
                  ylim(-1, 1) +
                  annotate(geom = "text",
                           x = 1,
                           y = 1,
                           label = paste("Module:", y),
                           size = 2,
                           hjust = 0) +
                  #geom_text(x = 1, 
                  #          y = 1,
                  #          label = paste("Module:", y)) +
                  geom_hline(yintercept = 0,
                             size = 0.25) +
                  labs(x = "",
                       y = "eigengene expression") +
                  #scale_x_discrete(labels = c(expression(NEC^'ENG-'),
                  #                            expression(NEC^'ENG+'),
                  #                            expression(TEC^'ENG-'),
                  #                            expression(TEC^'ENG+'))) +
                  #stat_pvalue_manual(comparison, 
                  #                   label = "{paste(text = p.sci)}",
                  #                  size = 2.1234) +
                  #geom_signif(y_position = comparison$y.position,
                  #            annotations = comparison$p.sci,
                  #            xmin = comparison$group1, 
                  #            xmax = comparison$group2,
                  #            parse = TRUE,
                  #            size = 0.2,
                  #            textsize = 1.75) +
                  theme_bw(base_size = 10) +
                  theme(axis.text.x = element_text(angle=90))}
  )


  # save everything
eigengene.plots.violin %>%
  export(here::here(plotsdir, paste("EigengenePlotsViolin", accession, "RDS", sep=".")))


```
